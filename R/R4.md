#### 복습

산점도(scatter plot) : 두 개 이상의 변수들 사이의 분포를 점으로 표시한 차트
두 변수의 관계를 시각적으로 분석할 때 유용



```R
price <- runif(10, min=1, max=100)
print(price)
plot(price, col="red")
par(new=T) #차트 추가
line_chart=1:100
#x축은 생성된 난수의 순서,  y축은 
plot(line_chart, type="l", col="red", axes=F, ann=F) #대각선 추가 

```

![1568075001764](assets/1568075001764.png)



**좌표평면상의 점 등을 선으로 연결**

```R
#좌표평면상의 점 등을 선으로 연결
par(mfrow=c(2, 2))
plot(price, type="l")  #실선
plot(price, type="o")  #원형과 실선
plot(price, type="h")  #직선
plot(price, type="s")  #꺽은선
```

![1568075069858](assets/1568075069858.png)



**중복된 데이터의 수만큼 plot점 크기 확대**

```R
#중복된 데이터의 수만큼 plot점 크기 확대
x<-c(1, 2, 3, 4, 2, 4)
y<-rep(2, 6)
table(x, y)  #빈도수


par(mfrow=c(1, 1))
plot(x, y)

```



![1568075267982](assets/1568075267982.png)





```R
> xy.df <- as.data.frame(table(x, y))
> xy.df
  x y Freq
1 1 2    1
2 2 2    2
3 3 2    1
4 4 2    2
> 
> plot(x, y, pch='@', col='blue', cex=0.5*xy.df$Freq, 
+      xlab="x벡터 원소", ylab="y벡터 원소")
```

![1568075446399](assets/1568075446399.png)







**child컬럼, parent컬럼을 대상으로 교차테이블을 생성 결과를 데이터프레임으로 생성**

```R
#child컬럼, parent컬럼을 대상으로 교차테이블을 생성 결과를 데이터프레임으로 생성
galtondf <- as.data.frame(table(galton$child, galton$parent))
head(galtondf)
str(galtondf)

> names(galtondf) <- c("child", "parent", "freq")
> head(galtondf)
  child parent freq
1  61.7     64    1
2  62.2     64    0
3  63.2     64    2
4  64.2     64    4
5  65.2     64    1
6  66.2     64    2
> parent <- as.numeric(galtondf$parent)
> child <- as.numeric(galtondf$child)
> 
> plot(parent, child, pch=21, col="blue", bg="green", 
+      cex=0.2*galtondf$freq, xlab="parent", ylab="child")


```

![1568076191327](assets/1568076191327.png)







===============================================================================

# R



## 그래프, 차트

### pairs()

pairs() : 변수 간의 관계를 차트로 그릴 수 있다





- pairs() : 변수 간의 관계를 차트로 그릴 수 있다
- graphics패키지에서 제공하는 paris()는 matrix 또는 data.frame의  numeric 컬럼을 대상으로 변수들 사이의 비교 결과를 행렬구조의 분산된 그래프로 제공합니다.
  

```R

> attributes(iris)  #
$names
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length"
[4] "Petal.Width"  "Species"     

$class
[1] "data.frame"

$row.names
  [1]   1   2   3   4   5   6   7   8   9  10  11  12
 [13]  13  14  15  16  17  18  19  20  21  22  23  24
 [25]  25  26  27  28  29  30  31  32  33  34  35  36
 [37]  37  38  39  40  41  42  43  44  45  46  47  48
 [49]  49  50  51  52  53  54  55  56  57  58  59  60
 [61]  61  62  63  64  65  66  67  68  69  70  71  72
 [73]  73  74  75  76  77  78  79  80  81  82  83  84
 [85]  85  86  87  88  89  90  91  92  93  94  95  96
 [97]  97  98  99 100 101 102 103 104 105 106 107 108
[109] 109 110 111 112 113 114 115 116 117 118 119 120
[121] 121 122 123 124 125 126 127 128 129 130 131 132
[133] 133 134 135 136 137 138 139 140 141 142 143 144
[145] 145 146 147 148 149 150

> 
> pairs(iris[, 1:4])
```

![1568076450343](assets/1568076450343.png)



### **3차원 산점도**

```R
install.packages("scatterplot3d")
library(scatterplot3d)
levels(iris$Species)
iris_setosa = iris[iris$Species=='setosa', ]

iris_versicolor = iris[iris$Species=='versicolor', ]
iris_virginica = iris[iris$Species=='virginica', ]
d3 <- scatterplot3d(iris$Petal.Length, iris$Sepal.Length,
                    iris$Sepal.Width, type='n')  #type='n'은 기본 산점도를 표시하지 않음
d3$points3d(iris_setosa$Petal.Length, iris_setosa$Sepal.Length ,
            iris_setosa$Sepal.Width, bg="orange", pch=21)

d3$points3d(iris_versicolor$Petal.Length, iris_versicolor$Sepal.Length ,
            iris_versicolor$Sepal.Width, bg="blue", pch=23)

d3$points3d(iris_virginica$Petal.Length, iris_virginica$Sepal.Length ,
            iris_virginica$Sepal.Width, bg="green", pch=25)
```



![1568078463493](assets/1568078463493.png)









## 데이터 전처리



- 데이터 분석 프로젝트에서는 70%이상의 시간을 데이터 변환과  조작, 필터링 등 전처리 작업에 소요됩니다.
- 데이터 전처리에 사용되는 유용한 패키지 : plyr, dplyr, reshape, reshape2패키지



### plyr



plyr 패키지는 두개 이상의 데이터프레임을 대상으로 key값을 이용하여 merge, 함수적용 , 요약 집계등의 기능을 제공합니다.

```R
install.packages("plyr")
library(plyr)

> x <- data.frame(id = c(1, 2, 3, 4, 5),
+                 height = c(160, 171, 173, 162, 165))
> 
> y <- data.frame(id = c(5, 1, 3, 2, 4),
+                 weight = c(55, 73, 60, 57, 75))
> 
> # join() : 두데이터프레임을 merge
> xyjoin <- join(x, y, by="id")
> xyjoin
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  5    165     55
> 
> x <- data.frame(id = c(1, 2, 3, 4, ,6),
+                 height = c(160, 171, 173, 162, 165))
Error in c(1, 2, 3, 4, , 6) : argument 5 is empty
> 
> leftjoin <- join(x, y, by="id") #왼쪽 데이터 프레임의 키값을 기준으로 merge
> leftjoin    #키에 join할 데이터가 없으면 NA로 출력
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  5    165     55
> 
> innerjoin <- join(x, y, by="id", type="inner")
> innerjoin   #innerjoin은 두 데이터프레임에서 키값이 있는 경우에만 조인을 수행
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  5    165     55
> 
> fulljoin <- join(x, y, by="id", type="full")
> fulljoin   #키 값이 존재하는 전체 관측치를 대상으로 조인 수행, 키에 join할 데이터가 없으면 NA로 출력
  id height weight
1  1    160     73
2  2    171     57
3  3    173     60
4  4    162     75
5  5    165     55


> x<-data.frame(key1=c(1,1, 2,2, 3), 
+               key2=c('a', 'b', 'c','d', 'e'),
+               val1 = c(10,20,30,40,50))
> 
> y<-data.frame(key1=c(3, 2, 2, 1, 1), 
+               key2=c('e', 'd', 'c','b', 'a'),
+               val1 = c(500,300,400,100,200))
> 
> xyjoin <- join (x, y, by=c('key1', 'key2'))
> xyjoin
  key1 key2 val1 val1
1    1    a   10  200
2    1    b   20  100
3    2    c   30  400
4    2    d   40  300
5    3    e   50  500

```







### apply



- apply(vec, func) - 결과는 벡터, 배열, 리스트
- lapply(vec|list, func)  - - 결과는  리스트
- sapply(vec, func) - 결과는 벡터, 배열, 행렬 반환
- tapply() - 데이터 셋에 집단 변수 (이산형 범주)를 대상으로 그룹별 함수 적용
- tapply(dataset, 집단변수, 함수)



#### tapply

```R
> names(iris)
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length"
[4] "Petal.Width"  "Species"     
> unique(iris$Species)
[1] setosa     versicolor virginica 
Levels: setosa versicolor virginica
> tapply(iris$Sepal.Length, iris$Species, mean)
    setosa versicolor  virginica 
     5.006      5.936      6.588 
> tapply(iris$Sepal.Length, iris$Species, sd)
    setosa versicolor  virginica 
 0.3524897  0.5161711  0.6358796 
```



####  ddply

- ddply() - 데이터 셋에 집단 변수(이산형 범주)를 대상으로 그룹별 함수를 여러개  적용할 수 있습니다.
- ddply(데이터 셋, 집단변수, 요약집계, 컬럼명=함수(변수))



```R
> avg_df <- ddply(iris, .(Species), summarise, avg=mean(Sepal.Length))
> avg_df
     Species   avg
1     setosa 5.006
2 versicolor 5.936
3  virginica 6.588
> str(avg_df)
'data.frame':	3 obs. of  2 variables:
 $ Species: Factor w/ 3 levels "setosa","versicolor",..: 1 2 3
 $ avg    : num  5.01 5.94 6.59
```

